module Pursley.Psb
  ( build,
    runPsb,
  )
where

import Codec.Serialise (serialise)
import Control.Exception (throwIO)
import Control.Lens.Combinators (over, _Left, _Nothing, _Right)
import Control.Monad (foldM, forM, join, when, (<=<))
import Control.Monad.Error.Class (MonadError (throwError))
import Control.Monad.Except (mapError, runExceptT)
import Control.Monad.IO.Class (MonadIO (liftIO))
import Control.Monad.Trans.Class (lift)
import Control.Monad.Trans.Except (ExceptT (ExceptT))
import Control.Monad.Trans.Writer (WriterT (runWriterT))
import Control.Monad.Writer.Class (MonadWriter, tell)
import Data.Bifunctor (Bifunctor (first))
import qualified Data.ByteString as BS
import qualified Data.List as L
import qualified Data.Map as M
import Data.Maybe (catMaybes, fromMaybe)
import qualified Data.Set as S
import Data.String (IsString (fromString))
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Text.IO as TIO
import qualified Language.PureScript as PS
import qualified Language.PureScript.CST as PS (parseFromFile, parseModuleFromFile)
import qualified Language.PureScript.CodeGen.JS as J
import qualified Language.PureScript.CodeGen.JS.Printer as JS
import qualified Language.PureScript.CoreFn as CF
import qualified Language.PureScript.Docs.Types as Docs
import qualified Language.PureScript.PSString as PSS
import qualified Paths_psb as Paths
import Pursley.Psb.Error (PsbError (..))
import Pursley.Psb.Options (Options (..))
import System.Directory (createDirectoryIfMissing, getModificationTime)
import qualified System.Directory as Directory
import System.Exit (exitFailure, exitSuccess)
import System.FilePath (isPathSeparator, pathSeparator, takeDirectory, takeExtension, (</>))
import qualified System.IO as IO
import Prelude

build ::
  forall m.
  (MonadIO m, MonadError PsbError m) =>
  -- | Path to input purescript module
  FilePath ->
  -- | Path to output directory
  FilePath ->
  -- | Path to FFI module (.js)
  Maybe FilePath ->
  -- | List of Externs file paths
  [FilePath] ->
  -- | Should generate sourcemaps
  Bool ->
  -- | Path to pursley cache directory
  FilePath ->
  m ()
build input outputDir ffi exts sourcemap cacheDir = do
  -- Step1. ExternsFile読み込み
  externs <- do
    extsOrErr <- runExceptT $ catMaybes <$> forM exts PS.readExternsFile
    case extsOrErr of
      Left errs -> throwError $ PursError errs
      Right externs -> pure externs

  -- Step2. inputをパース
  m@(PS.Module _ _ mn _ _) <- do
    parseRes <- runExceptT do
      content <- PS.readTextFile input
      let (_, parsed) = PS.parseFromFile input content
      pure parsed
    case join . over _Right (over _Left PursParseErrors) . over _Left PursError $ parseRes of
      Left err -> throwError err
      Right res -> pure res

  let makeActions =
        (PS.buildMakeActions "sample/output" (M.fromList [(mn, Left PS.RebuildAlways)]) M.empty False)
          { PS.getOutputTimestamp = const (pure Nothing),
            PS.progress = const (pure ()),
            PS.codegen = codegen,
            PS.ffiCodegen = ffiCodegen
          }
      makeOpts =
        PS.defaultOptions
          { PS.optionsNoComments = True,
            PS.optionsCodegenTargets = S.fromList [PS.JS, PS.JSSourceMap]
          }
  do
    makeRes <- liftIO $ PS.runMake makeOpts $ PS.rebuildModule makeActions externs m
    -- liftIO $ IO.print makeRes
    pure ()
  where
    codegen :: CF.Module CF.Ann -> Docs.Module -> PS.ExternsFile -> PS.SupplyT PS.Make ()
    codegen m _ exts = do
      let mn = CF.moduleName m
          outputDir' = outputDirectory m
      -- lift $ liftIO $ IO.print outputDir'
      foreignInclude <- case ffi of
        Just ffiJs
          | not $ requiresForeign m -> do
              return Nothing
          | otherwise -> do
              return $ Just "./foreign"
        Nothing
          | requiresForeign m -> throwError . PS.errorMessage' (CF.moduleSourceSpan m) $ PS.MissingFFIModule mn
          | otherwise -> return Nothing
      rawJs <- J.moduleToJs m foreignInclude
      -- dir <- lift $ makeIO "get the current directory" getCurrentDirectory
      let (js, mappings) = {-if sourcemap then prettyPrintJSWithSourceMaps rawJs else-} (JS.prettyPrintJS rawJs, [])
          jsFile = outputFilename m "index.js"
          -- mapFile = outputFIlename mn "index.js.map"
          -- prefix = ["Generated by psb version " <> T.pack (showVersion Paths.version) | usePrefix]
          -- js = T.unlines $ map ("// " <>) prefix ++ [pjs]
          mapRef = {-if sourceMaps then "//# sourceMappingURL=index.js.map\n" else -} ""
      lift $ do
        writeTextFile jsFile (TE.encodeUtf8 $ js <> mapRef)
      -- when sourceMaps $ genSourceMap dir mapFile (length prefix) mappings

      -- externs fileを現存と差分がある場合のみ出力する
      let externsFilename = outputFilename m "externs.cbor"
      -- currentExterns <- lift $ PS.readExternsFile externsFilename
      -- when ((serialise <$> currentExterns) /= Just (serialise exts)) do
      lift $ PS.writeCborFile externsFilename exts

    ffiCodegen :: CF.Module CF.Ann -> PS.Make ()
    ffiCodegen m = do
      let mn = CF.moduleName m
      case ffi of
        Just path
          | not $ requiresForeign m ->
              tell $ PS.errorMessage' (CF.moduleSourceSpan m) $ PS.UnnecessaryFFIModule mn path
          | otherwise -> do
              let ext = case takeExtension path of
                    ".ts" -> ".ts"
                    _ -> ".js"
              PS.copyFile path (outputFilename m ("foreign" <> ext))
        Nothing
          | requiresForeign m -> throwError . PS.errorMessage' (CF.moduleSourceSpan m) $ PS.MissingFFIModule mn
          | otherwise -> return ()

    outputDirectory :: CF.Module CF.Ann -> FilePath
    outputDirectory =
      maybe outputDir ((cacheDir </>) . (</> "output"))
        . ((safeHead . wordsWhen isPathSeparator) <=< L.stripPrefix cacheDir)
        . CF.modulePath

    wordsWhen :: (Char -> Bool) -> String -> [String]
    wordsWhen p s = case dropWhile p s of
      "" -> []
      s' -> w : wordsWhen p s''
        where
          (w, s'') = break p s'

    safeHead :: [a] -> Maybe a
    safeHead (x : _) = Just x
    safeHead _ = Nothing

    outputFilename :: CF.Module CF.Ann -> String -> FilePath
    outputFilename m fn =
      let mn = T.unpack . PS.runModuleName . CF.moduleName $ m
       in outputDirectory m </> mn </> fn

-- when (S.member Docs codegenTargets) $ do
--   lift $ writeJSONFile (outputFilename mn "docs.json") docs

requiresForeign :: CF.Module a -> Bool
requiresForeign = not . null . CF.moduleForeign

writeTextFile :: FilePath -> BS.ByteString -> PS.Make ()
writeTextFile path text = PS.makeIO ("write file: " <> T.pack path) $ do
  createParentDirectory path
  BS.writeFile path text

createParentDirectory :: FilePath -> IO ()
createParentDirectory = createDirectoryIfMissing True . takeDirectory

runPsb :: Options -> IO ()
runPsb (Options input ffi externs outdir sourcemaps cacheDir) = do
  res <- runExceptT $ do
    build input outdir ffi externs sourcemaps cacheDir
  case res of
    Right r -> do
      exitSuccess
    Left errs -> do
      -- print errs
      exitFailure
